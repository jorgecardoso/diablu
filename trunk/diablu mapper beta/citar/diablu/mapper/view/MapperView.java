/*
 * MapperView.java
 *
 * Created on 5 de Setembro de 2006, 23:15
 */

package citar.diablu.mapper.view;

// mapper
import citar.diablu.mapper.controller.MapperModelViewController;
import citar.diablu.mapper.controller.MapperViewController;
import citar.diablu.mapper.model.data.DiABluAnchorPoint;
import citar.diablu.mapper.model.data.DiABluLandmark;

// const
import static citar.diablu.mapper.model.settings.DiABluMapperCONSTANTS.*;

// j2se
import java.awt.Color;
import java.awt.Component;

import javax.swing.table.TableModel;
import javax.swing.JTable;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellRenderer;
import javax.swing.DefaultListModel;
import javax.swing.ListSelectionModel;
import javax.swing.ComboBoxModel;
import javax.swing.DefaultComboBoxModel;
import javax.swing.ButtonModel;
import javax.swing.JCheckBox;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.ListModel;
import javax.swing.JFileChooser;
import javax.swing.filechooser.FileFilter;

import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.Vector;
import java.util.Iterator;

// I/O
import java.io.File;
import citar.diablu.mapper.model.settings.DiABluMapperFileFilter;



/**
 *
 * @author  Nuno Rodrigues
 */
public class MapperView extends javax.swing.JFrame implements MapperViewController {
    
    // controller interface
    MapperModelViewController controller;
    
    //constants
    // TODO:update the constructor to include these constants
    static int UUID_COLUMN = 0;
    static int FNAME_COLUMN = 1;
    static int DEVICE_CLASS_COLUMN = 2;

    private boolean isAnchorSelected = false;
    private boolean isLandmarkSelected = false;
    
    private Vector <String> filteredDeviceClassList = new Vector <String> ();
    
    // Filechooser
    private final JFileChooser fc = new JFileChooser();
   
    /**
     *
     * BETA (JAVA 6)
     * add the file filter   
     * private final FileFilter fileFilter = new FileNameExtensionFilter(FILE_MAP_DESCRIPTION,FILE_MAP_EXTENSION);
     * fc.a
     *
     */  
    
    // LOG API
    private static Logger logger = Logger.getLogger("mapper.log");
    
    /**
     * Creates new form MapperView
     */
    public MapperView(MapperModelViewController controller) {
        
        // LOG Grain
        //logger.setLevel(Level.FINEST);
        logger.entering("MapperView","Constructor");
        this.controller = controller;
        initComponents();
        
        // set the i/o
        fc.setFileFilter(new DiABluMapperFileFilter());
        
        this.setVisible(true);
       
        
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {
        anchor_jp = new javax.swing.JPanel();
        detected_jsp = new javax.swing.JScrollPane();
        detected_jt = new javax.swing.JTable();
        addToLandmark = new javax.swing.JButton();
        landmark_jp = new javax.swing.JPanel();
        anchor_jsp = new javax.swing.JScrollPane();
        anchor_jt = new javax.swing.JTable();
        landmark_jsp = new javax.swing.JScrollPane();
        landmark_jl = new javax.swing.JList();
        landmarkName_jtf = new javax.swing.JTextField();
        landmarkName_jl = new javax.swing.JLabel();
        copyAllDetectedAnchorPoints_jchb = new javax.swing.JCheckBox();
        createLandmark_jb = new javax.swing.JButton();
        resetLandmark_jb = new javax.swing.JButton();
        deleteLandmark_jb = new javax.swing.JButton();
        removeAnchor_jb = new javax.swing.JButton();
        menu_jmb = new javax.swing.JMenuBar();
        file_jm = new javax.swing.JMenu();
        loadScoutMap_jmi = new javax.swing.JMenuItem();
        saveScoutMap_jmi = new javax.swing.JMenuItem();
        language = new javax.swing.JMenu();
        languagePT_jmi = new javax.swing.JMenuItem();
        languageEN_jmi = new javax.swing.JMenuItem();
        exit_jm = new javax.swing.JMenu();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("DiABlu Mapper (Alpha Testing)");
        setName("DiABlu Scout Map Designer Desktop Alpha");
        anchor_jp.setBorder(javax.swing.BorderFactory.createTitledBorder("Detected Anchor Points"));
        anchor_jp.setPreferredSize(new java.awt.Dimension(100, 100));
        detected_jt.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "UUID", "Friendly Name", "Device Class"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        detected_jt.setToolTipText("This table shows the Bluetooth detected devices");
        detected_jt.setGridColor(new java.awt.Color(0, 51, 204));
        ListSelectionModel detectedSM = detected_jt.getSelectionModel();
        detectedSM.addListSelectionListener(new ListSelectionListener() {
            public void valueChanged(ListSelectionEvent e) {
                //Ignore extra messages.
                if (e.getValueIsAdjusting()) return;

                ListSelectionModel lsm = (ListSelectionModel)e.getSource();
                if (lsm.isSelectionEmpty()) {

                    isAnchorSelected = false;
                    // disable button
                    addToLandmark.setEnabled(false);

                } else {

                    isAnchorSelected = true;

                    // enable button if there is a landmark selected
                    if (isLandmarkSelected) addToLandmark.setEnabled(true);

                }
            }
        });
        /*
        try {

            detected_jt.setDefaultRenderer(Class.forName
                ( "java.lang.String" ),new TableCellRenderer(){

                    public Component getTableCellRendererComponent (JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {

                        Component cell = this.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);

                        logger.finest("Rendering cell:"+row+","+column);
                        if( column == 3 )
                        {

                            String filter = (String) value;

                            if(filter.endsWith("[F]"))
                            {

                                cell.setBackground(Color.red);
                                // You can also customize the Font and Foreground this way
                                // cell.setForeground();
                                // cell.setFont();
                            }
                            else
                            {

                                cell.setBackground(Color.white);

                            }
                        }

                        return cell;
                    }

                });
            } catch (Exception e){

                logger.log(Level.FINE,"Error providing color table",e);

            }*/

            detected_jsp.setViewportView(detected_jt);

            addToLandmark.setText("Add to Landmark");
            addToLandmark.setEnabled(false);
            addToLandmark.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    addToLandmarkActionPerformed(evt);
                }
            });

            org.jdesktop.layout.GroupLayout anchor_jpLayout = new org.jdesktop.layout.GroupLayout(anchor_jp);
            anchor_jp.setLayout(anchor_jpLayout);
            anchor_jpLayout.setHorizontalGroup(
                anchor_jpLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                .add(anchor_jpLayout.createSequentialGroup()
                    .addContainerGap()
                    .add(anchor_jpLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                        .add(detected_jsp, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 611, Short.MAX_VALUE)
                        .add(addToLandmark))
                    .addContainerGap())
            );
            anchor_jpLayout.setVerticalGroup(
                anchor_jpLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                .add(anchor_jpLayout.createSequentialGroup()
                    .add(detected_jsp, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 118, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                    .add(addToLandmark)
                    .addContainerGap())
            );

            landmark_jp.setBorder(javax.swing.BorderFactory.createTitledBorder("Landmarks"));
            anchor_jt.setModel(new javax.swing.table.DefaultTableModel(
                new Object [][] {

                },
                new String [] {
                    "UUID", "Friendly Name", "Device Class"
                }
            ) {
                Class[] types = new Class [] {
                    java.lang.String.class, java.lang.String.class, java.lang.String.class
                };
                boolean[] canEdit = new boolean [] {
                    false, false, false
                };

                public Class getColumnClass(int columnIndex) {
                    return types [columnIndex];
                }

                public boolean isCellEditable(int rowIndex, int columnIndex) {
                    return canEdit [columnIndex];
                }
            });
            ListSelectionModel anchorSM = anchor_jt.getSelectionModel();
            anchorSM.addListSelectionListener(new ListSelectionListener() {
                public void valueChanged(ListSelectionEvent e) {
                    //Ignore extra messages.
                    if (e.getValueIsAdjusting()) return;

                    ListSelectionModel lsm = (ListSelectionModel)e.getSource();
                    if (lsm.isSelectionEmpty()) {

                        //no rows are selected
                        removeAnchor_jb.setEnabled(false);

                    } else {

                        removeAnchor_jb.setEnabled(true);

                    }
                }
            });
            anchor_jsp.setViewportView(anchor_jt);

            landmark_jl.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
            ListSelectionModel landmarkSM = landmark_jl.getSelectionModel();
            landmarkSM.addListSelectionListener(new ListSelectionListener() {
                public void valueChanged(ListSelectionEvent e) {
                    //Ignore extra messages.
                    if (e.getValueIsAdjusting()) return;

                    ListSelectionModel lsm = (ListSelectionModel)e.getSource();

                    if (lsm.isSelectionEmpty()) {

                        logger.finest("Empty list selection");
                        //no rows are selected
                        isLandmarkSelected = false;
                        addToLandmark.setEnabled(isLandmarkSelected);
                        deleteLandmark_jb.setEnabled(false);
                        resetLandmark_jb.setEnabled(false);
                        controller.selectedLandmark("");

                    } else {

                        logger.finest("Processing list selection");
                        isLandmarkSelected = true;
                        if (isAnchorSelected) addToLandmark.setEnabled(isLandmarkSelected);
                        deleteLandmark_jb.setEnabled(true);
                        resetLandmark_jb.setEnabled(true);
                        String landmarkName = landmark_jl.getSelectedValue().toString();
                        logger.finer("Selected Landmark:"+landmarkName);
                        controller.selectedLandmark(landmarkName);

                    }

                }
            });
            landmark_jsp.setViewportView(landmark_jl);

            landmarkName_jl.setText("Name:");

            copyAllDetectedAnchorPoints_jchb.setText("Copy all detected anchor points on landmark creation");
            copyAllDetectedAnchorPoints_jchb.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
            copyAllDetectedAnchorPoints_jchb.setMargin(new java.awt.Insets(0, 0, 0, 0));
            copyAllDetectedAnchorPoints_jchb.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    copyAllDetectedAnchorPoints_jchbActionPerformed(evt);
                }
            });

            createLandmark_jb.setText("Create");
            createLandmark_jb.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    createLandmark_jbActionPerformed(evt);
                }
            });

            resetLandmark_jb.setText("Reset");
            resetLandmark_jb.setEnabled(false);
            resetLandmark_jb.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    resetLandmark_jbActionPerformed(evt);
                }
            });

            deleteLandmark_jb.setText("Delete");
            deleteLandmark_jb.setEnabled(false);
            deleteLandmark_jb.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    deleteLandmark_jbActionPerformed(evt);
                }
            });

            removeAnchor_jb.setText("Remove Anchor");
            removeAnchor_jb.setEnabled(false);
            removeAnchor_jb.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    removeAnchor_jbActionPerformed(evt);
                }
            });

            org.jdesktop.layout.GroupLayout landmark_jpLayout = new org.jdesktop.layout.GroupLayout(landmark_jp);
            landmark_jp.setLayout(landmark_jpLayout);
            landmark_jpLayout.setHorizontalGroup(
                landmark_jpLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                .add(landmark_jpLayout.createSequentialGroup()
                    .addContainerGap()
                    .add(landmark_jpLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                        .add(landmark_jpLayout.createSequentialGroup()
                            .add(landmark_jsp, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 121, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                            .add(anchor_jsp, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 484, Short.MAX_VALUE))
                        .add(copyAllDetectedAnchorPoints_jchb)
                        .add(landmark_jpLayout.createSequentialGroup()
                            .add(landmarkName_jl)
                            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                            .add(landmarkName_jtf, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 236, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                            .add(createLandmark_jb)
                            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                            .add(resetLandmark_jb)
                            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                            .add(deleteLandmark_jb)
                            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                            .add(removeAnchor_jb)))
                    .addContainerGap())
            );
            landmark_jpLayout.setVerticalGroup(
                landmark_jpLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                .add(landmark_jpLayout.createSequentialGroup()
                    .add(landmark_jpLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING, false)
                        .add(landmark_jsp, 0, 0, Short.MAX_VALUE)
                        .add(anchor_jsp, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 120, Short.MAX_VALUE))
                    .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                    .add(landmark_jpLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                        .add(landmarkName_jl)
                        .add(removeAnchor_jb)
                        .add(deleteLandmark_jb)
                        .add(resetLandmark_jb)
                        .add(createLandmark_jb)
                        .add(landmarkName_jtf, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                    .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                    .add(copyAllDetectedAnchorPoints_jchb)
                    .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            );

            file_jm.setText("File");
            loadScoutMap_jmi.setText("Load Scout Map");
            loadScoutMap_jmi.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    loadScoutMap_jmiActionPerformed(evt);
                }
            });

            file_jm.add(loadScoutMap_jmi);

            saveScoutMap_jmi.setText("Save Scout Map");
            saveScoutMap_jmi.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    saveScoutMap_jmiActionPerformed(evt);
                }
            });

            file_jm.add(saveScoutMap_jmi);

            menu_jmb.add(file_jm);

            language.setText("Language");
            languagePT_jmi.setText("Portugu\u00eas");
            languagePT_jmi.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    languagePT_jmiActionPerformed(evt);
                }
            });

            language.add(languagePT_jmi);

            languageEN_jmi.setText("English");
            languageEN_jmi.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    languageEN_jmiActionPerformed(evt);
                }
            });

            language.add(languageEN_jmi);

            menu_jmb.add(language);

            exit_jm.setText("Exit");
            exit_jm.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    exit_jmActionPerformed(evt);
                }
            });
            exit_jm.addMouseListener(new java.awt.event.MouseAdapter() {
                public void mouseClicked(java.awt.event.MouseEvent evt) {
                    exit_jmMouseClicked(evt);
                }
            });

            menu_jmb.add(exit_jm);

            setJMenuBar(menu_jmb);

            org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
            getContentPane().setLayout(layout);
            layout.setHorizontalGroup(
                layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                .add(anchor_jp, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 643, Short.MAX_VALUE)
                .add(landmark_jp, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            );
            layout.setVerticalGroup(
                layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                .add(layout.createSequentialGroup()
                    .add(anchor_jp, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 184, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                    .add(landmark_jp, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            );
            pack();
        }// </editor-fold>//GEN-END:initComponents

    private void exit_jmMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_exit_jmMouseClicked

      controller.exit(false);
      
    }//GEN-LAST:event_exit_jmMouseClicked

    private void exit_jmActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exit_jmActionPerformed

      controller.exit(false);
        
    }//GEN-LAST:event_exit_jmActionPerformed

    /**
     * This method trys to remove the selected anchor point
     * from the selected landmark
     * Fails if by removing the selected landmark the remaining
     * anchor points are the same as other landmark.
     *
     */
    private void removeAnchor_jbActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_removeAnchor_jbActionPerformed

        Vector <DiABluAnchorPoint> dapList = new Vector <DiABluAnchorPoint> ();
        int totalSelectedAnchors = anchor_jt.getSelectedRowCount();
        TableModel tm = anchor_jt.getModel();
                                                         
        if (totalSelectedAnchors > 0){
        
            int[] apIndex = new int[totalSelectedAnchors];
            apIndex = anchor_jt.getSelectedRows();            
            logger.finest("Inspecting "+totalSelectedAnchors+" selected anchor points");
            
            String selectedUUID;
            String selectedFName;
            String selectedDeviceClass;
            DiABluAnchorPoint dap;            
            
            for (int i=0;i<totalSelectedAnchors;i++){
            
                logger.finest("Inspecting index:"+apIndex[i]);
                selectedUUID = tm.getValueAt(apIndex[i],UUID_COLUMN).toString();                    
                selectedFName = tm.getValueAt(apIndex[i],FNAME_COLUMN).toString();
                selectedDeviceClass = tm.getValueAt(apIndex[i],DEVICE_CLASS_COLUMN).toString();
                logger.finest("Adding "+selectedFName+"@"+selectedUUID+"["+selectedDeviceClass+"]");
                dap = new DiABluAnchorPoint(selectedUUID,selectedFName,selectedDeviceClass);
                dapList.add(dap);
                    
                                                
                
            }
                  
        }                  
        
        // get the landmark name
        
        
        
       controller.removeFromLandmark(getSelectedLandmarkName(),dapList);
        

    }//GEN-LAST:event_removeAnchor_jbActionPerformed

    // This method set/unsets the copy all flag
    private void copyAllDetectedAnchorPoints_jchbActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_copyAllDetectedAnchorPoints_jchbActionPerformed
       
       boolean tempFlag = copyAllDetectedAnchorPoints_jchb.isSelected();
       controller.setCopyAllFlag(tempFlag);
       //copyOnlyDetected_jchb.setEnabled(!tempFlag);

    }//GEN-LAST:event_copyAllDetectedAnchorPoints_jchbActionPerformed

    private void deleteLandmark_jbActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_deleteLandmark_jbActionPerformed
        
        String landmarkName = getSelectedLandmarkName();
        if (landmarkName.equalsIgnoreCase("none")) {
            
            // ERROR no landmark selected
            // TODO: Log the action
            
        } else {
                
            controller.deleteLandmark(landmarkName);
            
        }
        
    }//GEN-LAST:event_deleteLandmark_jbActionPerformed

    private void resetLandmark_jbActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_resetLandmark_jbActionPerformed

        String landmarkName = getSelectedLandmarkName();
        if (landmarkName.equalsIgnoreCase("none")) {
            
            // ERROR no landmark selected
            // TODO: Log the action
            
        } else {
                
            controller.resetLandmark(landmarkName);
        }
        
    }//GEN-LAST:event_resetLandmark_jbActionPerformed

    private void createLandmark_jbActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_createLandmark_jbActionPerformed

        logger.entering("MapperView","createLandmark()");
        
        // check the copy flags
        boolean copyAll = copyAllDetectedAnchorPoints_jchb.isSelected();
        //boolean copyFiltered = copyOnlyDetected_jchb.isSelected();
        logger.finest("getAnchorPointList()"+"Flag Copy All Status:"+copyAll);
        //logger.finest("getAnchorPointList()"+"Flag Copy Filtered Status:"+copyFiltered);
        
        String newLandmarkName = landmarkName_jtf.getText();
        Vector <DiABluAnchorPoint> anchorPointList = new Vector <DiABluAnchorPoint> ();
      
        // get the corresponding anchorlist
        if (copyAll){
            
            anchorPointList = getAnchorPointList();
            
        } else {
            
            
            anchorPointList = getSelectedAnchorPointList();
            
        }
           
        
        // DEBUG ONLY
        for (DiABluAnchorPoint dap:anchorPointList){
            
            logger.finest("createLandmark() "+dap.getFname()+"@"+dap.getUUID());
            
        }
    
        logger.exiting("MapperView","createLandmark()"+":"+newLandmarkName,anchorPointList);
        controller.createLandmark(newLandmarkName,anchorPointList);
        
    }//GEN-LAST:event_createLandmark_jbActionPerformed

    /**
     *  This method is activated each time the user checks/unchecks the 
     * copy only detected jcheckbox
     * We only do: 
     * set/unset the internal flag isCopyOnlyDetected 
     * enable/disable the jcheckbox "copy all" 
     *
     */
        
    /**
     * This method returns the list of filtered device classes
     *
     */
    @Deprecated
    private Vector <String> getFilteredDeviceClassList() {
        
        Vector <String> filteredDeviceClassList = new Vector <String> ();
        // get the list of device class and check for validated ones
        //DefaultComboBoxModel dcbm = (DefaultComboBoxModel) deviceClass_jcb.getModel();
        
        // get the list of menu components
       // int totalClasses = filter_jm.getComponentCount();
        JCheckBox filterItem;
        
      //  for (int i=0;i<totalClasses;i++){
        //
           // filterItem = (JCheckBox) filter_jm.getComponent(i);
          //  if (filterItem.isSelected()) filteredDeviceClassList.add(filterItem.toString());
            
        
        return filteredDeviceClassList;
        
    }    
        
        
    private void saveScoutMap_jmiActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveScoutMap_jmiActionPerformed

        // inform controller
        controller.save(chooseFile("Save"));
        
    }//GEN-LAST:event_saveScoutMap_jmiActionPerformed

    private void loadScoutMap_jmiActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_loadScoutMap_jmiActionPerformed

        // inform controller
        controller.load(chooseFile("Load"));
        
    }//GEN-LAST:event_loadScoutMap_jmiActionPerformed

    private void languageEN_jmiActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_languageEN_jmiActionPerformed

        controller.setLanguage("EN");
        
    }//GEN-LAST:event_languageEN_jmiActionPerformed

    private void languagePT_jmiActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_languagePT_jmiActionPerformed

        controller.setLanguage("PT");
        
    }//GEN-LAST:event_languagePT_jmiActionPerformed

    /**
     * This method adds the anchor point selected in the detected table
     * to the current selected landmark
     *
     */
    private void addToLandmarkActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_addToLandmarkActionPerformed

        
        String landmarkName = getSelectedLandmarkName();
        logger.finest("Adding Anchors to "+landmarkName);
        Vector <DiABluAnchorPoint> anchorPointList = new Vector <DiABluAnchorPoint> ();
        anchorPointList = getSelectedDetectedAnchorPoint();
        
        if (landmarkName.equalsIgnoreCase("none")) {
            
            logger.warning("No landmark selected");
            
        } else {
            
            logger.finest("Sending "+anchorPointList.size()+" anchors to "+landmarkName);            
            controller.addToLandmark(landmarkName,anchorPointList);
            
        } 
        
    }//GEN-LAST:event_addToLandmarkActionPerformed

    /**
     * 
     * this method creates a landmark with the preferred anchor point list
     *
     */
    /**
     * This method reads the detected table model and returns a list of 
     * all the DiABluAnchorPoints detected
     *
     */
    private Vector <DiABluAnchorPoint> getAnchorPointList(){
        
        logger.entering("MapperView","getAnchorPointList()");
        
        Vector <DiABluAnchorPoint> apList = new Vector <DiABluAnchorPoint> ();
        int totalAnchor = detected_jt.getRowCount();
        logger.finest("getAnchorPointList()"+"Detected Anchor Point:"+totalAnchor);
        
        if (totalAnchor>0){
            
            String uuidT = "";
            String fnameT = "";
            String deviceClassT = "";
            logger.finest("getAnchorPointList()"+"Getting Anchor Point List");
            //DiABluAnchorPoint dapTEMP = new DiABluAnchorPoint();
            for (int i=0;i<totalAnchor;i++){
                          
              uuidT = getDetectedInfo(i,UUID_COLUMN);
              fnameT = getDetectedInfo(i,FNAME_COLUMN);
              deviceClassT = getDetectedInfo(i,DEVICE_CLASS_COLUMN);
              logger.finest("getAnchorPointList()"+"Adding Anchor Point:"+fnameT+"@"+uuidT+"["+deviceClassT+"]");
              apList.add(new DiABluAnchorPoint(uuidT,fnameT,deviceClassT));
              
            }
        
        }
        
        logger.exiting("MapperView","getAnchorPointList()"+"Returning "+apList.size()+" elements",apList);
        return apList;
    }
    /**
     * This method returns the current selected anchor Points
     * returns empty if none selected
     *
     *
     */
    private Vector <DiABluAnchorPoint> getSelectedAnchorPointList(){
        
        Vector <DiABluAnchorPoint> sapList = new Vector <DiABluAnchorPoint>();
        ListSelectionModel lsm;
        TableModel tm;
        int listSize;
        String uuidT,fnameT,deviceClassT; 
        
        // check if there's work to be done'
        int selectedAnchors = detected_jt.getSelectedRowCount();
        if ( selectedAnchors > 0 ){
            
            lsm = detected_jt.getSelectionModel();
            tm = detected_jt.getModel();
            listSize = tm.getRowCount();
            for (int i=0;i<listSize;i++){
                
                if (lsm.isSelectedIndex(i)){
                    
                     uuidT = getDetectedInfo(i,UUID_COLUMN);
                     fnameT = getDetectedInfo(i,FNAME_COLUMN);
                     deviceClassT = getDetectedInfo(i,DEVICE_CLASS_COLUMN);
                     logger.finest("getSelectedAnchorPointList()"+"Adding Anchor Point:"+fnameT+"@"+uuidT+"["+deviceClassT+"]");
                     sapList.add(new DiABluAnchorPoint(uuidT,fnameT,deviceClassT));
                    
                }
                
                
            }
            
            
        }
                
        return sapList;
    }
    
    
    /**
     * This method returns a filtered list of anchor points
     * present in the detected table model
     *
     */
    private Vector <DiABluAnchorPoint> getFilteredAnchorPointList(){
        
        int totalAnchor = detected_jt.getRowCount();
        Vector <DiABluAnchorPoint> entireList = getAnchorPointList();
        
        if (entireList.size()>0){
            
            DiABluAnchorPoint dapTEMP = new DiABluAnchorPoint();
            for (String banishedDeviceClass : filteredDeviceClassList ){
            
                    for (Iterator <DiABluAnchorPoint> dapIterator = entireList.iterator(); dapIterator.hasNext();){
                    
                        dapTEMP = dapIterator.next();
            
                        if (dapTEMP.getDeviceClass().equalsIgnoreCase(banishedDeviceClass)){
                        
                            //our current device is banished from automatic copy
                            // remove it from the list
                            dapIterator.remove();
                            // nothing more to do with this anchor point
                            break;
                        
                        }
                    
                   }
                                        
            }
            
        }
        
        return entireList;
        
    }
    
    
    /**
     * This method returns the name of the currently selected landmark
     * if there's none selected it returns "none"
     */
    private String getSelectedLandmarkName(){
        
        String selectedLandmark = "none";
        int index = landmark_jl.getSelectedIndex();
        
        if ( index != -1 ){
        
            ListModel lmodel = landmark_jl.getModel();
        
            selectedLandmark = lmodel.getElementAt(index).toString();                
            
        }
        
        return selectedLandmark;
    }
    
    /**
     * This method returns a Vector of the selected DiABluAnchorPoints
     * from Landmarks table if there's none it returns an empty Vector
     *
     */
    private Vector <DiABluAnchorPoint> getSelectedDetectedAnchorPoint(){
               
        Vector <DiABluAnchorPoint> dapList = new Vector <DiABluAnchorPoint> ();
        
        
        // make sure there is some work to do
        int totalSelectedRows = detected_jt.getSelectedRowCount();       
        
        if (totalSelectedRows > 0){
        
            int[] apIndex = new int[totalSelectedRows];
            apIndex = detected_jt.getSelectedRows();            
            logger.finest("Inspecting "+totalSelectedRows+" selected rows");

            TableModel tm = detected_jt.getModel();
            String selectedUUID;
            String selectedFName;
            String selectedDeviceClass;
            DiABluAnchorPoint dap;            
            
            for (int i=0;i<totalSelectedRows;i++){
            
                logger.finest("Inspecting index:"+apIndex[i]);
                selectedUUID = tm.getValueAt(apIndex[i],UUID_COLUMN).toString();                    
                selectedFName = tm.getValueAt(apIndex[i],FNAME_COLUMN).toString();
                selectedDeviceClass = tm.getValueAt(apIndex[i],DEVICE_CLASS_COLUMN).toString();
                logger.finest("Adding "+selectedFName+"@"+selectedUUID+"["+selectedDeviceClass+"]");
                dap = new DiABluAnchorPoint(selectedUUID,selectedFName,selectedDeviceClass);
                dapList.add(dap);
                    
                                                
                
            }
                  
        }                  
        
        logger.finest("Returning "+dapList.size()+" Anchors");
        return dapList;
    
    }
      
    /**
     * This method returns the name of the currently selected uuid
     * from the detected table
     * if there's none selected it returns "none"
     */
    private String getSelectedDetectedAnchorUUID() {
        
        String anchorUUID = "none";
        int selectedRow = detected_jt.getSelectedRow();               
        anchorUUID = getDetectedInfo(selectedRow,UUID_COLUMN);
        return anchorUUID;
        
    }
    
    /**
     * This method returns the info located @ index,column (parameter)
     *
     */
    private String getDetectedInfo(int index,int column){
        
        TableModel detectedModel = detected_jt.getModel();
        String detectedInfo = "";
        
        try {
                     
            detectedInfo = detectedModel.getValueAt(index,column).toString();
            
        } catch (Exception e){
            
            logger.log(Level.WARNING,"Error trying to reach detected Table at "+index+","+column+"Exception:",e);
            
        }
        
        return detectedInfo; 
                        
    }
    
    /**
     * This method returns the name of the currently selected fname
     * from the detected table
     * if there's none selected it returns "none"
     */
    private String getSelectedDetectedAnchorFName() {
        
        String anchorFName = "none";
        int selectedRow = detected_jt.getSelectedRow();               
        anchorFName = getDetectedInfo(selectedRow,FNAME_COLUMN);
                
        return anchorFName;
        
    }   
    
         
    /**
     * This method returns the name of the currently selected device class
     * from the detected table
     * if there's none selected it returns "none"
     */
    private String getSelectedDetectedAnchorDeviceClass() {
        
        String anchorDeviceClass = "none";
        int selectedRow = detected_jt.getSelectedRow();               
        anchorDeviceClass = getDetectedInfo(selectedRow,DEVICE_CLASS_COLUMN);
        return anchorDeviceClass;
        
    }
           

    
    /**
     * This method returns a vector with the selected 
     * anchor points from the landmark anchor point table
     * if there's none selected it returns an empty vector
     *
     */
    private Vector <DiABluAnchorPoint> getLandmarkSelectedAnchors(){
        
       Vector <DiABluAnchorPoint> dapList = new Vector <DiABluAnchorPoint> ();              
              
       // make sure we've got work to do'
       int totalSelected = anchor_jt.getSelectedRowCount();
       if (totalSelected > 0){
           
            TableModel tm = anchor_jt.getModel();
            ListSelectionModel lsm = anchor_jt.getSelectionModel();
            String uuidT;
            String fnameT;
            String deviceClassT;
            DiABluAnchorPoint dapT;
            
            for (int i=0;i<totalSelected;i++){
                
                if (lsm.isSelectedIndex(i)){
                    
                    uuidT = tm.getValueAt(i,UUID_COLUMN).toString();
                    fnameT = tm.getValueAt(i,FNAME_COLUMN).toString();
                    deviceClassT = tm.getValueAt(i,DEVICE_CLASS_COLUMN).toString();
                    dapT = new DiABluAnchorPoint(uuidT,fnameT,deviceClassT);
                    dapList.add(dapT);
                    
                }
                
            }
           
           
       }
              
       return dapList;
       
    }    
    
    /**
     *  View's interface methods
     *  Described in the MapperViewController interface
     *
     *
     */
       
    // informs the view of the current table of detected devices
    public void setDetectedAnchorList(Vector <DiABluAnchorPoint> dapList){
            
    if (dapList == null){
            
            logger.warning("Null Argument");
            return;
            
        } 
        
        DefaultTableModel tm = (DefaultTableModel) detected_jt.getModel();
        Vector <String> foundDeviceClasses = new Vector <String> ();
        
        int currentSize = tm.getRowCount();        
        for (int i=0;i<currentSize;i++){
            
            tm.removeRow(0);
            
        }

        for (DiABluAnchorPoint dap:dapList){
            
            String foundDeviceClass = dap.getDeviceClass();
            if (isDeviceClassFiltered(foundDeviceClass)) foundDeviceClass+="[F]";
            tm.addRow(new Object[] {dap.getUUID(),dap.getFname(),foundDeviceClass});
            foundDeviceClasses.add(foundDeviceClass);
                   
        }
         
        if (dapList.size()>0){
            
            
            updateCopyFilter(foundDeviceClasses);
           // copyOnlyDetected_jchb.setEnabled(true);
                        
            copyAllDetectedAnchorPoints_jchb.setEnabled(true);
            
        } else {
            
           // copyOnlyDetected_jchb.setEnabled(false);
            copyAllDetectedAnchorPoints_jchb.setEnabled(false);            
            
        }
        
        
        detected_jt.setModel((TableModel)tm);
    
    }
    
    /**
     *  This method updates the combo box present in the copy filter checkbox
     *
     */
    @Deprecated
    private void updateCopyFilter(Vector <String> foundClasses){
      
      // first we clean the menu
     // filter_jm.removeAll();
        
      // now we add the new classes
      JCheckBoxMenuItem processedClass;
      
      // compare to see which ones are filtered
      boolean filterClass = false;
      for (String found:foundClasses){
          
          for (String current:filteredDeviceClassList){
              
              if (current.equalsIgnoreCase(found)){
                  
                  filterClass = true;
                  break;
              }
          }
          processedClass = new JCheckBoxMenuItem();
          processedClass.setText(found);
          
          processedClass.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                JCheckBoxMenuItem jcbmi = (JCheckBoxMenuItem)evt.getSource();
                String signature = jcbmi.getText();
                boolean selection = jcbmi.isSelected();
                filterDeviceChanged(signature,selection);
            }
           });
          
 
        //  filter_jm.add(processedClass);
      }
      
      
    }
    
    private void filterDeviceChanged(String deviceClass,boolean selected){
        
        if (selected){
            filteredDeviceClassList.add(deviceClass);
            
        } else {
        for (Iterator filterIterator = filteredDeviceClassList.iterator();filterIterator.hasNext();){
            
            String compare = (String) filterIterator.next();
            if (compare.equalsIgnoreCase(deviceClass)){ 
                // found a match
                filterIterator.remove();
                break;
            }
        
        }
        
    
        }
        
    }
    
    
    private boolean inList(String check,Vector <String> checkList){
        
        boolean found = false;
        
        for (String element:checkList){
            
            if (element.equalsIgnoreCase(check)) {
                found = true;
                break;
            }
        }
        
        return found;
    }
    
    // This method populates the filter menu
    @Deprecated
    private void populateFilterDeviceClassCombo(Vector <String> detectedList){
        
        // first we clean the menu
       // filter_jm.removeAll();
        
        // then we add the list checked against our filter device classes list
       
        JCheckBox deviceClassTEMP;
        boolean filteredFlag;
                                
        for (String s:detectedList){
            
            filteredFlag = false;
            for (String filter:filteredDeviceClassList){
                
                if (s.equalsIgnoreCase(filter)){
                    
                    filteredFlag = true;
                    break;
                    
                }
                
            }
            
            deviceClassTEMP = new JCheckBox(s,filteredFlag);
            
           // filter_jm.add(deviceClassTEMP);    
        }
   
    }
    
    // informs the view of the selected landmarks anchor points
    public void setLandmarkAnchorList(Vector <DiABluAnchorPoint> dapList){
    
        logger.entering("MapperView","setLandmarkAnchorList()",dapList);  
        
        // clean the current table
        DefaultTableModel tm = (DefaultTableModel) anchor_jt.getModel();             
        int currentSize = tm.getRowCount();        
        for (int i=0;i<currentSize;i++){
            
            tm.removeRow(0);
            
        }
        
        // verify that's work to do
        if (dapList==null || dapList.isEmpty()){
            
            logger.warning("Empty or null argument");
            return;
            
            
        }
       
        logger.finest("Getting Landmark Anchor Point List");
        for (DiABluAnchorPoint dap:dapList){
            
            logger.finest("setLandmarkAnchorList()"+"Adding Anchor Point:"+dap.getFname()+"@"+dap.getUUID());
            tm.addRow(new Object[] {dap.getUUID(),dap.getFname(),dap.getDeviceClass()});                          
            
        }
                        
        // set the model
        anchor_jt.setModel((TableModel)tm);
        logger.exiting("MapperView","setLandmarkAnchorList()");
        
    }
   
    
    
    // informs the view of the current landmark list
    public void setLandmarkList(Vector <DiABluLandmark> landList){
    
        landmark_jl.removeAll();
        DefaultListModel listModel = new DefaultListModel();
        
        for (DiABluLandmark dlm:landList){
            
            listModel.addElement(dlm.getName());
   
        }
        landmark_jl.setModel((ListModel)listModel);
    
    }
    
    
    // set & get automatic discovery
    /**
    public void setAutomaticDiscovery(boolean isAutomatic){
    
       search_jb.setEnabled(!isAutomatic);
       automatic_jchb.setEnabled(isAutomatic);    
    
    }
    
    // informs the view of the current discovery delay
    public void setDiscoveryDelay(String btDelay){
    
        
            delay_jtf.setText(btDelay);
    
    }
    */
    // checks/unchecks the copy all option in creating landmarks
    public void setCopyAllFlag(boolean copyAll){
    
            copyAllDetectedAnchorPoints_jchb.setSelected(copyAll);
           // copyOnlyDetected_jchb.setEnabled(!copyAll);
            
    }
    
    // checks/unchecks the filtered copy option in creating landmarks
    @Deprecated
    public void setFilteredCopy(boolean filteredCopy){
    
           // copyOnlyDetected_jchb.setSelected(filteredCopy);
            copyAllDetectedAnchorPoints_jchb.setEnabled(!filteredCopy);
    
    }
    
    // sets the list of filtered device classes
    @Deprecated
    public void setFilteredDeviceClasses(Vector <String> filterList){
    
        this.filteredDeviceClassList = filterList;
        
        
        
    }
    
    /**
     * Updates the log output information
     *
     */
     @Deprecated
     public void setLogOutput(boolean[] logOut){
    /*              
         if (logOut.length==3){
         
             logOutConsole_jchbmi.setSelected(logOut[0]);         
             logOutFile_jchbmi.setSelected(logOut[1]);         
             logOutWindow_jchbmi.setSelected(logOut[2]);
         
         } else {
             
             logger.warning("MapperView"+" setLogOutput() "+":received a wrong argument:"+logOut.length);
             
         }
      */   
     }
     
    /**
     * This method informs the controller that the user
     * selected a different output log
     *
     */ 
     @Deprecated
    private void logChanged(){
        /*
        boolean[] logStatus = (new boolean[] { logOutConsole_jchbmi.isSelected(), logOutFile_jchbmi.isSelected(),logOutWindow_jchbmi.isSelected()});
        controller.setLogOutput(logStatus);
        */
        
        
    }
    
    /**
     * This method receives a Device class String and 
     * checks if belongs to the filtered devices list
     * Returns true if so, false otherwise
     *  
     *
     */
    private boolean isDeviceClassFiltered(String deviceClass){
       
        logger.finest("Checking device class:"+deviceClass);
        boolean result = false;
        
        for (String f:filteredDeviceClassList){
            
            if (f.equalsIgnoreCase(deviceClass)) return true;
            
        }                
                
        logger.finest("Is "+deviceClass+"filtered ?"+result);
        return result;
        
    }
    
    /**
     *  This method opens a file chooser window and let's the user
     *  select/create a file
     *
     *
     */
    private File chooseFile(String approveButton){
        
        
        
        int returnVal = fc.showDialog(this,approveButton);
        
        if (returnVal == JFileChooser.APPROVE_OPTION){
            
            return fc.getSelectedFile();
            
        } else {
                        
            logger.warning("Error:Unable to get file!");
            return null;
            
        }                
        
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton addToLandmark;
    private javax.swing.JPanel anchor_jp;
    private javax.swing.JScrollPane anchor_jsp;
    private javax.swing.JTable anchor_jt;
    private javax.swing.JCheckBox copyAllDetectedAnchorPoints_jchb;
    private javax.swing.JButton createLandmark_jb;
    private javax.swing.JButton deleteLandmark_jb;
    private javax.swing.JScrollPane detected_jsp;
    private javax.swing.JTable detected_jt;
    private javax.swing.JMenu exit_jm;
    private javax.swing.JMenu file_jm;
    private javax.swing.JLabel landmarkName_jl;
    private javax.swing.JTextField landmarkName_jtf;
    private javax.swing.JList landmark_jl;
    private javax.swing.JPanel landmark_jp;
    private javax.swing.JScrollPane landmark_jsp;
    private javax.swing.JMenu language;
    private javax.swing.JMenuItem languageEN_jmi;
    private javax.swing.JMenuItem languagePT_jmi;
    private javax.swing.JMenuItem loadScoutMap_jmi;
    private javax.swing.JMenuBar menu_jmb;
    private javax.swing.JButton removeAnchor_jb;
    private javax.swing.JButton resetLandmark_jb;
    private javax.swing.JMenuItem saveScoutMap_jmi;
    // End of variables declaration//GEN-END:variables
    
}
